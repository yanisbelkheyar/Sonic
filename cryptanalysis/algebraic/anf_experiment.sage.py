#In this file we give function to compute the anf for Sonic
#we also provide some function to extract the degree distribution get the degree, and get the number of term

# This file was *autogenerated* from the file anf_experiment.sage
from sage.all_cmdline import *   # import sage library

_sage_const_256 = Integer(256);
_sage_const_128 = Integer(128);
_sage_const_15 = Integer(15);
_sage_const_7 = Integer(7);
_sage_const_25 = Integer(25);
_sage_const_1 = Integer(1);
_sage_const_2 = Integer(2);
_sage_const_57 = Integer(57);
_sage_const_58 = Integer(58);
_sage_const_0 = Integer(0)#!/usr/bin/env sage

import sys
import itertools
import sage.misc.prandom
import sage.rings.polynomial.multi_polynomial_element
from sage.rings.polynomial.pbori import substitute_variables
from sage.all import *

STATE_SIZE = 512  
H_STATE_SIZE = 256

#Generate variables
            
xvars = ["x" + str(i) for i in range(STATE_SIZE)]
kvars = ["k" + str(i) for i in range(STATE_SIZE)]
T1 = TermOrder('deglex', STATE_SIZE)
T2 = TermOrder('deglex', STATE_SIZE)
T = T1 + T2
R = BooleanPolynomialRing(names=xvars+kvars, order=T)
a = R.inject_variables()
generators = list(R.gens())
bit_variables = generators[:STATE_SIZE]
key_variables = generators[STATE_SIZE:]  
statek0 = [bit_variables[i] + key_variables[i] for i in range(STATE_SIZE)]

state0_left = [bit_variables[i] for i in range(H_STATE_SIZE)]
state0_right = [bit_variables[i+H_STATE_SIZE] for i in range(H_STATE_SIZE)]
#state0_right = [ 0 for i in range(H_STATE_SIZE)]

state_left_init,state_right_init = state0_left,state0_right

#generate input state

#step function for the round function of Sonic and Simon

def pi(state_bits):
    return [state_bits[(7 *i) % H_STATE_SIZE] for i in range(H_STATE_SIZE)]

def theta(state_bits):
    return [state_bits[i] + state_bits[(i+3 ) % H_STATE_SIZE] + state_bits[(i+20 ) % H_STATE_SIZE] for i in range(H_STATE_SIZE)]

def chi(state_bits):
    return [state_bits[(i+5) % H_STATE_SIZE] + ((state_bits[(i+1) % H_STATE_SIZE]) * state_bits[(i+2) % H_STATE_SIZE]) for i in range(H_STATE_SIZE)]

def xor_state(state_1,state_2):
    return [state_1[i] + state_2[i] for i in range(H_STATE_SIZE)]


#compute the linear and non linear function for the round function of sonic and simon

def linear_part(state_bits):
    # Theta step
    state_bits = theta(state_bits)
    # Pi step
    state_bits = pi(state_bits)
    return state_bits

def left_output(state_bits_left,state_bits_right):
    # Chi step
    state_bits = chi(state_bits_left)
    # Xor left right input
    state_bits = xor_state(state_bits,state_bits_right)
    #Pi step
    state_bits = pi(state_bits) 
    return state_bits

def right_output(state_bits_left):
    #linear step (theta + pi)
    state_bits = linear_part(state_bits_left) 
    return state_bits

def print_state(state):
    for i in range(len(state)):
        print(state[i])


#Compute the full anf for nbr_round round
def anf_full(nbr_round):
    state_left =  state_left_init
    state_right = state_right_init
    state_tmp = state_left
    for i in range(nbr_round):
        state_tmp = right_output(state_left)
        state_left = left_output(state_left,state_right)
        state_right = state_tmp
        
    state_str_left = [list(state_left[i]) for i in range(len(state_left))]
    state_str_right = [list(state_right[i]) for i in range(len(state_right))]

    return state_str_left,state_str_right

#return the maximum degree of the anf 
def get_max_deg_from_anf(anf):
    term_0 = anf[0]
    return len(term_0)

#return the number of term in each side of the anf
def get_nbr_term(anf_left,anf_right):

    #print(anf_right[0])
    min = len(anf_right[0])
    max = 0
    for i in anf_right:
        if(len(i)<min):
            min = len(i)
        if(len(i)>max):
            max = len(i)
    print("min nbr term anf right",min)
    print("max nbr term anf right",max)
    
    min = len(anf_left[0])
    max = 0
    #print(anf_left[0])
    for i in anf_left:
        if(len(i)<min):
            min = len(i)
        if(len(i)>max):
            max = len(i)
    print("min nbr term anf left",min)
    print("max nbr term anf left",max)

    

#return the degree distribution in each side of the anf
def get_distribution(anf_left,anf_right):

    distri_left,distri_right = [0]*32,[0]*32

    for j in anf_left:
        #if(len(str(j).split("*"))==3):
            #print(distri_left[len(str(j).split("*"))], str(j))
        distri_left[len(str(j).split("*"))] += 1

    for j in anf_right:
        distri_right[len(str(j).split("*"))] += 1

    print("distri left")
    for i in range(32):
        if(not distri_left[i]==0):
            print(i," : ",distri_left[i])

    print()
    print("distri right")
    for i in range(32):
        if(not distri_right[i]==0):
            print(i," : ",distri_right[i])

    print()
    print()
            
#compute the anf for nbr_round by computing the full anf for nbr_round-1 round and extending it for one position for one round
def anf_extended_1(nbr_round):
    state_left =  state_left_init
    state_right = state_right_init
    state_tmp = state_left

    for i in range(nbr_round-1):
        print(i)
        state_tmp = right_output(state_left)
        state_left = left_output(state_left,state_right)
        state_right = state_tmp

    print("distribution after ",nbr_round-1," round :")
    get_distribution(list(state_left[0]),list(state_right[0]))

    distri_left,distri_right = [0]*32,[0]*32
    
    #exenting one round for one coordinate
    state_right_tmp = state_left[0] + state_left[9] + state_left[96]

    print("right part for ",nbr_round)

    anf_right = list(state_right_tmp)

    print(len(anf_right))
    
    for j in anf_right:
        distri_right[len(str(j).split("*"))] += 1
    
    state_left = state_left[5] + state_right[0] + (state_left[1]+1)*state_left[2]

    print("left part for ",nbr_round)

    anf_left = list(state_left)

    print(len(anf_left))

    for j in anf_left:
        distri_left[len(str(j).split("*"))] += 1
    
    #return str(state_left).split("+"),str(state_right_tmp).split("+")

#return the maximum degree for nbr_ronud in the left side by computing the anf for nbr_round-2 and extending it for 2 round 
def max_deg_anf_exented_2(nbr_round):
    state_left = state_left_init
    state_right = state_right_init
    state_tmp = state_left

    for i in range(nbr_round-1):
        state_tmp = right_output(state_left)
        state_left = left_output(state_left,state_right)
        state_right = state_tmp

    #to change to make it a function of the rotation values
    state0_chi = (state_left[1])*state_left[2] + state_left[5] + state_right[0]
    state1_chi = (state_left[112])*state_left[113] + state_left[116] + state_right[111]

    print("partial anf 5 round")
    
    anf0_max_deg,anf1_max_deg = 0,0
    tmp = 0
    for i in range(1000):
        tmp = state0_chi.lm()
        #print(tmp)
        state0_chi -= tmp
        anf0_max_deg += tmp
        tmp = state1_chi.lm()
        state1_chi -= tmp
        #print(tmp)
        anf1_max_deg += tmp

    res = anf1_max_deg*anf0_max_deg

    print(len(str(res.lm()).split("*")))

    print(len(state0_chi.set()))

    return 0 


nbr_round = int(sys.argv[1])

index = 0

if(len(sys.argv)==2):

    if(nbr_round>=5):
         #max_deg_anf_exented_2(nbr_round)
        anf_left,anf_right = anf_extended_1(nbr_round)
        get_nbr_term(anf_left,anf_right)
    else:
        anf_left,anf_right = anf_full(nbr_round)
        #for i in range(len(anf_left[index])):
        #    print(anf_left[index][i])
        get_nbr_term(anf_left,anf_right)
    
    get_distribution(anf_left[index],anf_right[index])
    
if(len(sys.argv)==3):

    nbr_round_end = int(sys.argv[2])

    for i in range(nbr_round,nbr_round_end):
        #max_deg_anf_exented_2(nbr_round)

        anf_left,anf_right = anf_full(i)
        #get_nbr_term(anf_left,anf_right)
        get_distribution(anf_left[index],anf_right[index])
